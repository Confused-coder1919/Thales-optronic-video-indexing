<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Three Hero Background</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: radial-gradient(circle at 20% 10%, rgba(15, 118, 110, 0.35), transparent 60%),
          radial-gradient(circle at 80% 30%, rgba(45, 212, 191, 0.22), transparent 55%),
          linear-gradient(140deg, rgba(255, 255, 255, 0.9), rgba(240, 244, 248, 0.7));
      }

      body {
        position: relative;
      }

      #fallback {
        position: absolute;
        inset: 0;
        background: radial-gradient(circle at 20% 20%, rgba(15, 118, 110, 0.32), transparent 60%),
          radial-gradient(circle at 80% 20%, rgba(45, 212, 191, 0.24), transparent 60%),
          linear-gradient(140deg, rgba(255, 255, 255, 0.9), rgba(239, 244, 248, 0.72));
        z-index: 0;
      }

      canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
        z-index: 1;
      }
    </style>
  </head>
  <body>
    <div id="fallback"></div>
    <canvas id="scene"></canvas>

    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script>
      (function () {
        const canvas = document.getElementById("scene");
        const reduceMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;

        function canUseWebGL() {
          try {
            const testCanvas = document.createElement("canvas");
            return !!(
              window.WebGLRenderingContext &&
              (testCanvas.getContext("webgl") || testCanvas.getContext("experimental-webgl"))
            );
          } catch (err) {
            return false;
          }
        }

        if (reduceMotion || !canUseWebGL() || !window.THREE) {
          canvas.style.display = "none";
          return;
        }

        const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.6));

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(48, 1, 0.1, 100);
        camera.position.z = 6;

        const group = new THREE.Group();
        scene.add(group);

        const mesh = new THREE.Mesh(
          new THREE.IcosahedronGeometry(1.6, 2),
          new THREE.MeshStandardMaterial({
            color: 0x0f766e,
            emissive: 0x0f3f3b,
            roughness: 0.45,
            metalness: 0.2,
            transparent: true,
            opacity: 0.35,
            wireframe: true,
          })
        );
        group.add(mesh);

        const particleCount = 220;
        const positions = new Float32Array(particleCount * 3);
        for (let i = 0; i < particleCount; i += 1) {
          positions[i * 3] = (Math.random() - 0.5) * 6;
          positions[i * 3 + 1] = (Math.random() - 0.5) * 3.5;
          positions[i * 3 + 2] = (Math.random() - 0.5) * 4;
        }
        const pointsGeometry = new THREE.BufferGeometry();
        pointsGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
        const points = new THREE.Points(
          pointsGeometry,
          new THREE.PointsMaterial({
            color: 0x2dd4bf,
            size: 0.04,
            transparent: true,
            opacity: 0.6,
          })
        );
        group.add(points);

        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const light = new THREE.DirectionalLight(0xffffff, 0.6);
        light.position.set(4, 3, 5);
        scene.add(light);

        function resize() {
          const width = document.body.clientWidth;
          const height = document.body.clientHeight;
          if (!width || !height) {
            return;
          }
          renderer.setSize(width, height, false);
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
        }

        window.addEventListener("resize", resize);
        resize();

        let running = true;
        let raf = null;

        function animate() {
          if (!running) {
            return;
          }
          raf = window.requestAnimationFrame(animate);
          group.rotation.y += 0.0012;
          group.rotation.x += 0.0006;
          renderer.render(scene, camera);
        }

        document.addEventListener("visibilitychange", () => {
          running = document.visibilityState === "visible";
          if (running) {
            animate();
          } else if (raf) {
            window.cancelAnimationFrame(raf);
          }
        });

        animate();
      })();
    </script>
  </body>
</html>
